/*
 * Copyright (C) 2014 zulily, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.zulily.omicron.alert;

import com.google.common.collect.ComparisonChain;
import com.zulily.omicron.Utils;
import org.joda.time.DateTime;

import static com.google.common.base.Preconditions.checkArgument;
import static com.google.common.base.Preconditions.checkNotNull;

/**
 * An alert is a message or notification about the state of a process or groups of processes. They are generated by
 * {@link com.zulily.omicron.sla.Policy} implementations when a {@link com.zulily.omicron.scheduling.ScheduledTask}
 * is evaluated to be in one of two states: failed and successful.
 * <p/>
 * Alerts from failed SLA policys are sent on a configured delay schedule (every 5 minutes, etc)
 * while successful alerts are only sent after a scheduled task leaves a failed SLA state.
 * <p/>
 * Tracking and sending failed/successful alerts is implemented in {@link com.zulily.omicron.alert.AlertManager}
 */
public final class Alert implements Comparable<Alert> {

  private final boolean failed;
  private final long timstamp;
  private final String policyName;
  private final String message;
  private final int lineNumber;
  private final String commandLine;
  private long lastAlertTimestamp = Utils.DEFAULT_TIMESTAMP;

  /**
   * Constructor
   * @param policyName The name of the policy generating the alert
   * @param message The message generated by the policy evaluation
   * @param lineNumber The line number in crontab for the scheduled task
   * @param commandLine The command line being executed
   * @param failed true if the alert is for failure of the Policy, false for success
   */
  public Alert(final String policyName,
               final String message,
               final int lineNumber,
               final String commandLine,
               final boolean failed) {

    this.timstamp = DateTime.now().getMillis();
    this.policyName = checkNotNull(policyName, "policyName");
    this.message = checkNotNull(message, "message");
    this.lineNumber = lineNumber;

    checkArgument(lineNumber > 0, "lineNumber must be positive");

    this.commandLine = checkNotNull(commandLine, "commandLine");
    this.failed = failed;
  }

  public long getTimstamp() {
    return timstamp;
  }

  public String getPolicyName() {
    return policyName;
  }

  public String getMessage() {
    return message;
  }

  public int getLineNumber() {
    return lineNumber;
  }

  public String getCommandLine() {
    return commandLine;
  }

  public long getLastAlertTimestamp() {
    return lastAlertTimestamp;
  }

  public void setLastAlertTimestamp(long lastAlertTimestamp) {
    this.lastAlertTimestamp = lastAlertTimestamp;
  }

  public boolean isFailed() {
    return failed;
  }

  @Override
  public int compareTo(Alert o) {
    checkNotNull(o, "compare to null instance");

    return ComparisonChain.start()
      .compare(timstamp, o.timstamp)
      .compare(policyName, o.policyName)
      .compare(message, o.message)
      .result();
  }

  @Override
  public boolean equals(Object o) {
    return o instanceof Alert
      && this.timstamp == ((Alert) o).timstamp
      && this.policyName.equals(((Alert) o).policyName)
      && this.message.equals(((Alert) o).message)
      && this.lineNumber == ((Alert) o).lineNumber
      && this.commandLine.equals(((Alert) o).commandLine);
  }

  @Override
  public int hashCode() {
    return this.policyName.hashCode();
  }

}
